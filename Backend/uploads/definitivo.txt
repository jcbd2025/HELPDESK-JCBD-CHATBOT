import os
import sys
import subprocess
import webbrowser
import pyautogui
import pygetwindow as gw
import pytesseract
import pandas as pd
import re
import time
import datetime
import openpyxl
from openpyxl import Workbook, load_workbook
from PIL import Image, ImageGrab
from selenium import webdriver
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.action_chains import ActionChains
import fitz
import difflib
from pdf2image import convert_from_path
from PIL import ImageOps, ImageEnhance
from PIL import ImageGrab, Image
import cv2
import numpy as np


pyautogui.FAILSAFE = False

# ---------- CONFIGURACI√ìN ----------
pytesseract.pytesseract.tesseract_cmd = (
    r"C:\\Program Files\\Tesseract-OCR\\tesseract.exe"
)
CHROME_PATH = r"C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe"

REGION_IDENTIDAD = (200, 300, 700, 600)
REGION_RUT = (680, 300, 1200, 600)
REGION_MODAL = (150, 150, 900, 300)
COORDENADA_DOC_IDENTIDAD = (597, 431)
COORDENADA_DOC_RUT = (1076, 430)
Validacion_backup = (200, 450, 700, 900)
DESCARGAS_DIR = "C:\\convocatoria"
BASE_DIR = os.path.dirname(
    sys.executable if getattr(sys, "frozen", False) else __file__
)
EXCEL_INPUT = os.path.join(BASE_DIR, "datos.xlsx")
EXCEL_OUTPUT = os.path.join(BASE_DIR, "registro_validaciones.xlsx")

# ---------- FUNCIONES ----------


def lanzar_chrome_con_debug():
    subprocess.Popen(
        [
            CHROME_PATH,
            "--remote-debugging-port=9222",
            "--user-data-dir=C:\\chrome_sesion_temp",
            "--incognito",  # Opcional: modo inc√≥gnito
            "--disable-infobars",
            "--disable-extensions",
            "--disable-popup-blocking",
            "--disable-features=site-per-process",
            "--disable-background-timer-throttling",
            "--disable-renderer-backgrounding",
        ]
    )
    time.sleep(5)

"""def abrir_pagina():
    try:
        win = gw.getWindowsWithTitle("Convocatoria")[0]
        win.activate()
        win.maximize()
    except:
        pass"""


def login():
    pyautogui.press("tab", presses=3, interval=0.1)
    pyautogui.write("Val.Doc1", interval=0.1)
    pyautogui.press("tab")
    pyautogui.write("Val.Doc1", interval=0.1)
    pyautogui.press("tab", presses=4, interval=0.1)
    pyautogui.press("space")
    time.sleep(1)
    pyautogui.press("tab", presses=3, interval=0.1)
    pyautogui.press("enter")
    time.sleep(10)


def limpiar_cedula(texto):
    return re.sub(r"\D", "", texto)  


def conectar_con_selenium():
    chrome_options = Options()
    chrome_options.add_experimental_option("debuggerAddress", "localhost:9222")
    chrome_options.add_argument("--disable-extensions")
    chrome_options.add_argument("--disable-popup-blocking")
    return webdriver.Chrome(options=chrome_options)


def buscar_modulo(driver):
    try:
        WebDriverWait(driver, 10).until(
            EC.element_to_be_clickable(
                (By.XPATH, "//span[contains(text(), 'Convocatoria')]")
            )
        ).click()
        print("Clic en 'Convocatoria'.")
        time.sleep(3)
        WebDriverWait(driver, 10).until(
            EC.element_to_be_clickable(
                (By.XPATH, "//a[contains(text(), 'Validaci√≥n de Documentos')]")
            )
        ).click()
        print("Clic en 'Validaci√≥n de Documentos'.")
    except Exception as e:
        print(f"Error accediendo al m√≥dulo: {e}")


def configurar_filtro(driver, fila):
    valor1 = str(fila["nombre"]).strip()
    valor2 = str(fila["estado"]).strip()
    valor3 = str(fila["nodos"]).strip()
    valor4 = str(fila["sitio"]).strip()
    valor_cargo = str(fila["cargo"]).strip().lower()

    print("Buscando:", valor1, valor2, valor3, valor4)

    try:
        time.sleep(5)
        
        select_elem = WebDriverWait(driver, 10).until(
            EC.presence_of_element_located((By.ID, "mat-select-0"))
        )

        
        driver.execute_script("arguments[0].scrollIntoView(true);", select_elem)
        time.sleep(0.5)

        
        driver.execute_script("arguments[0].click();", select_elem)
        time.sleep(1)

       
        opciones = WebDriverWait(driver, 10).until(
            EC.presence_of_all_elements_located((By.XPATH, "//mat-option"))
        )
        for opt in opciones:
            if opt.text.strip().lower() == valor1.lower():
                opt.click()
                print(f"Proceso seleccionado: {opt.text.strip()}")
                break

    except Exception as e:
        print(f"Error SELECT 1: {e}")
    time.sleep(5)
    try:
        time.sleep(5)
        WebDriverWait(driver, 10).until(
            EC.element_to_be_clickable((By.ID, "mat-select-2"))
        ).click()
        time.sleep(5)
        for opt in WebDriverWait(driver, 10).until(
            EC.presence_of_all_elements_located((By.XPATH, "//mat-option"))
        ):
            if opt.text.strip().lower() == valor2.lower():
                opt.click()
                print(f"Estado seleccionado: {opt.text.strip()}")
                break
    except Exception as e:
        print(f"Error SELECT 2: {e}")
    time.sleep(5)
    try:
        time.sleep(5)
        WebDriverWait(driver, 10).until(
            EC.element_to_be_clickable((By.ID, "mat-select-4"))
        ).click()
        time.sleep(5)
        for opt in WebDriverWait(driver, 10).until(
            EC.presence_of_all_elements_located((By.XPATH, "//mat-option"))
        ):
            if opt.text.strip().lower() == valor3.lower():
                opt.click()
                print(f"Nodo seleccionado: {opt.text.strip()}")
                break
    except Exception as e:
        print(f"Error SELECT 3: {e}")
    time.sleep(5)
    try:
        input_sitio = WebDriverWait(driver, 10).until(
            EC.presence_of_element_located((By.ID, "mat-input-2"))
        )
        input_sitio.click()
        time.sleep(5)
        for opcion in WebDriverWait(driver, 5).until(
            EC.presence_of_all_elements_located((By.XPATH, "//mat-option//span"))
        ):
            if opcion.text.strip().lower() == valor4.lower():
                opcion.click()
                print(f"Sitio '{valor4}' seleccionado.")
                break
    except Exception as e:
        print(f"Error sitio: {e}")
    time.sleep(5)
    try:
        for label in WebDriverWait(driver, 10).until(
            EC.presence_of_all_elements_located(
                (By.XPATH, "//label[@class='mdc-label']")
            )
        ):
            if label.text.strip().lower() == valor_cargo:
                label.click()
                print(f"Cargo '{valor_cargo}' seleccionado.")
                break
    except Exception as e:
        print(f"Error cargo: {e}")
    time.sleep(6)
    try:
        paginador = WebDriverWait(driver, 10).until(
            EC.presence_of_element_located((By.ID, "mat-select-6"))
        )
        driver.execute_script(
            "arguments[0].scrollIntoView({block: 'center'});", paginador
        )
        time.sleep(1)
        paginador.click()
        print("Click en paginador realizado.")
        time.sleep(1)

        
        opciones = WebDriverWait(driver, 10).until(
            EC.presence_of_all_elements_located(
                (By.XPATH, "//div[@role='listbox']//mat-option//span")
            )
        )

        for opcion in opciones:
            texto = opcion.text.strip()
            print(f"üîé Opci√≥n encontrada en paginador: {texto}")
            if texto == "100":
                opcion.click()
                print("100 resultados por p√°gina seleccionados.")
                break
        else:
            print("No se encontr√≥ la opci√≥n '100' en el paginador.")
    except Exception as e:
        print(f"Error en paginador: {e}")
        time.sleep(5)
    

time.sleep(4)


time.sleep(2)


def extraer_cedula_modal(driver):
    try:
        print("Buscando c√©dula directamente en el HTML del modal...")

        
        elemento_modal = WebDriverWait(driver, 10).until(
            EC.presence_of_element_located((By.CLASS_NAME, "modal-about"))
        )

        texto_modal = elemento_modal.text.strip()
        print(f"Texto del modal: {texto_modal}")

        
        match = re.search(r"Documento\s+(\d+)", texto_modal)
        if match:
            cedula = match.group(1)
            print(f"C√©dula extra√≠da del HTML: {cedula}")
            return cedula
        else:
            print("No se encontr√≥ la c√©dula en el texto del modal.")
            return None
    except Exception as e:
        print(f"Error extrayendo c√©dula desde el DOM: {e}")
        return None


def esperar_descarga(directorio, timeout=15):
    tiempo_inicio = time.time()
    while time.time() - tiempo_inicio < timeout:
        archivos = [f for f in os.listdir(directorio) if f.endswith(".pdf")]
        if archivos:
            archivos.sort(
                key=lambda f: os.path.getmtime(os.path.join(directorio, f)),
                reverse=True,
            )
            return os.path.join(directorio, archivos[0])
        time.sleep(1)
    return None


def verificar_archivo_cargado(region):
    time.sleep(5)
    captura = ImageGrab.grab(bbox=region)
    texto_detectado = pytesseract.image_to_string(captura, lang="spa").lower()
    captura.save("captura_region.png")
    print(f"Texto detectado en la regi√≥n: {texto_detectado.strip()}")
    return "no ha cargado archivo" not in texto_detectado


def verificar_aprobacion_documento(driver, tipo_documento):
    try:
        titulos = WebDriverWait(driver, 10).until(
            EC.presence_of_all_elements_located((By.CSS_SELECTOR, "h5.card-title"))
        )

        for titulo in titulos:
            if tipo_documento.lower() in titulo.text.lower():
                span = titulo.find_element(By.TAG_NAME, "span")
                estado = span.text.strip().lower()
                print(f"üîç Estado detectado para {tipo_documento}: {estado.upper()}")

                if "aprobado" in estado:
                    return "aprobado"
                elif "rechazado" in estado:
                    return "rechazado"
                else:
                    return None

        print(f"‚ö†Ô∏è No se encontr√≥ el documento '{tipo_documento}' en el DOM.")
        return None

    except Exception as e:
        print(f"‚ùå Error al verificar aprobaci√≥n de '{tipo_documento}': {e}")
        return None

def validacion_backup(cedula, region):
    time.sleep(5)

    # Paso 1: Captura original
    captura = ImageGrab.grab(bbox=region)
    captura.save("captura_backup.png")

    # Paso 2: OCR directo sin procesar
    texto_detectado = pytesseract.image_to_string(captura, lang="spa").lower()
    print(f"üïµÔ∏è OCR inicial: {texto_detectado.strip()}")

    # Paso 3: Validaci√≥n directa
    if cedula_en_ocr_fuzzy(limpiar_cedula(cedula), limpiar_cedula(texto_detectado)):
        print("‚úÖ C√©dula detectada en OCR sin procesar.")
        return True

    print("‚ö†Ô∏è No detectada en OCR directo. Intentando con preprocesamiento...")

    # Paso 4: Preprocesar (escala de grises + binarizaci√≥n)
    imagen_cv = cv2.cvtColor(np.array(captura), cv2.COLOR_RGB2BGR)
    gris = cv2.cvtColor(imagen_cv, cv2.COLOR_BGR2GRAY)
    _, binarizada = cv2.threshold(gris, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)
    cv2.imwrite("captura_backup_procesada.png", binarizada)

    # Paso 5: OCR mejorado
    texto_mejorado = pytesseract.image_to_string(binarizada, lang="spa").lower()
    print(f"üïµÔ∏è OCR mejorado: {texto_mejorado.strip()}")

    # Paso 6: Validaci√≥n con OCR mejorado
    if cedula_en_ocr_fuzzy(limpiar_cedula(cedula), limpiar_cedula(texto_mejorado)):
        print("‚úÖ C√©dula detectada tras preprocesamiento.")
        return True
    else:
        print("‚ùå C√©dula no encontrada ni con preprocesamiento.")
        return False


def extraer_anio_generacion(contenido_pdf):
    # Busca la l√≠nea que contiene exactamente "Fecha generaci√≥n documento PDF: DD-MM-YYYY"
    match = re.search(
        r"Fecha\s+generaci[o√≥]n\s+documento\s+PDF[:\s]+(\d{2})[-/](\d{2})[-/](\d{4})",
        contenido_pdf,
        re.IGNORECASE,
    )
    if match:
        dia, mes, anio = match.groups()
        print(f"Fecha de generaci√≥n encontrada: {dia}-{mes}-{anio}")
        return int(anio)
    else:
        print("No se encontr√≥ la fecha de generaci√≥n exacta en el PDF.")
        return None


def cedula_en_ocr_fuzzy(cedula_limpia, texto_limpio, umbral=0.85):
    for i in range(len(texto_limpio) - len(cedula_limpia) + 1):
        segmento = texto_limpio[i : i + len(cedula_limpia)]
        similitud = difflib.SequenceMatcher(None, segmento, cedula_limpia).ratio()
        if similitud >= umbral:
            print(f"Coincidencia fuzzy: {segmento} (similitud {similitud:.2f})")
            return True
    return False


def esperar_ventana_guardar(timeout=5):
    for _ in range(timeout * 2):
        if any(
            "Guardar como" in w.title for w in gw.getWindowsWithTitle("Guardar como")
        ):
            return True
        time.sleep(0.5)
    return False


def validar_documento_identidad(x, y, cedula, nombre_doc):
    try:
        time.sleep(2)
        pyautogui.moveTo(x, y, duration=0.5)
        time.sleep(1)
        pyautogui.click()
        print(f"Clic en bot√≥n de descarga para {nombre_doc} ({x}, {y})")
        time.sleep(2)
        if not esperar_ventana_guardar():
            print("No se abri√≥ la ventana de guardar. Documento inv√°lido.")
            try:
                # Esperar el campo de observaci√≥n espec√≠fico
                # Espera el campo de observaci√≥n
                textarea_observacion = WebDriverWait(driver, 10).until(
                    EC.presence_of_element_located((By.ID, "observacionDoc"))
                )

                # Escribe la observaci√≥n
                textarea_observacion.clear()
                textarea_observacion.send_keys(
                    "Documento inv√°lido, revise el documento y vu√©lvalo a cargar"
                )
                print("Observaci√≥n escrita correctamente.")

                # Espera y hace clic en el bot√≥n Rechazar
                boton_rechazar = WebDriverWait(driver, 10).until(
                    EC.element_to_be_clickable(
                        (By.XPATH, "//button[.//span[text()='Rechazar']]")
                    )
                )
                boton_rechazar.click()
                print("Bot√≥n 'Rechazar' clickeado correctamente.")
                return False
            except Exception as e:
                print(f"Error al escribir observaci√≥n o rechazar documento del bloque Documento RUT: {e}")
                return False

        pyautogui.hotkey("ctrl", "l")
        pyautogui.write(DESCARGAS_DIR, interval=0.1)
        pyautogui.press("enter")
        pyautogui.press("tab", presses=9, interval=0.1)
        pyautogui.press("enter")

        archivo = esperar_descarga(DESCARGAS_DIR)
        if not archivo:
            print(f"No se detect√≥ un archivo PDF descargado para {nombre_doc}")
            return False

        cedula_limpia = limpiar_cedula(cedula)
        contiene_cedula = False

        # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Primera validaci√≥n: TEXTO por PyMuPDF
        try:
            with fitz.open(archivo) as doc:
                contenido_total = ""

                for pagina in doc:
                    texto = pagina.get_text()
                    contenido_total += texto
                    texto_limpio = limpiar_cedula(texto)
                    print(f"Texto extra√≠do de {nombre_doc}: {texto[:300]}...")
                    if cedula_en_ocr_fuzzy(cedula_limpia, texto_limpio):
                        contiene_cedula = True
                        print(f"{nombre_doc} contiene la c√©dula (por texto plano)")
                        break

                # Verificar si hay p√°ginas rotadas
                if not contiene_cedula:
                    print(
                        "No se encontr√≥ por texto plano. Verificando p√°ginas rotadas..."
                    )
                    contenido_rotado = ""
                    for pagina in doc:
                        if pagina.rotation in [90, 180, 270]:
                            pix = pagina.get_pixmap()
                            img = Image.frombytes(
                                "RGB", [pix.width, pix.height], pix.samples
                            )
                            img = img.rotate(-pagina.rotation, expand=True)
                            texto_rotado = pytesseract.image_to_string(img, lang="spa")
                            contenido_rotado += texto_rotado

                    texto_limpio = limpiar_cedula(contenido_rotado)
                    if cedula_en_ocr_fuzzy(cedula_limpia, texto_limpio):
                        contiene_cedula = True
                        print(f"{nombre_doc} contiene la c√©dula (por texto rotado)")

        except Exception as e:
            print(f"Error al procesar texto del PDF: {e}")

        # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Segunda validaci√≥n: OCR con rotaci√≥n de imagen
        if not contiene_cedula:
            print("No se encontr√≥ por texto. Intentando OCR con im√°genes rotadas...")
            try:
                imagenes = convert_from_path(
                    archivo, dpi=300, poppler_path=r"C:\poppler-24.08.0\Library\bin"
                )

                for i, imagen in enumerate(imagenes):
                    for angulo in [0, 90, 180, 270]:
                        img = imagen.rotate(angulo, expand=True)
                        img = img.convert("L")
                        img = ImageOps.autocontrast(img)
                        img = ImageEnhance.Contrast(img).enhance(2.5)
                        img = img.resize((img.width * 2, img.height * 2), Image.LANCZOS)

                        custom_config = r"--oem 3 --psm 6 -c tessedit_char_whitelist=0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz√Å√â√ç√ì√ö√°√©√≠√≥√∫.- "
                        texto_ocr = pytesseract.image_to_string(
                            img, lang="eng", config=custom_config
                        )
                        texto_limpio = limpiar_cedula(texto_ocr)

                        print(
                            f"üîç OCR para {nombre_doc} (rotado {angulo}¬∞): {texto_ocr[:100]}..."
                        )

                        if cedula_en_ocr_fuzzy(cedula_limpia, texto_limpio):
                            contiene_cedula = True
                            print(
                                f"{nombre_doc} contiene la c√©dula (por OCR rotado {angulo}¬∞)"
                            )
                            break
                    if contiene_cedula:
                        break

                if not contiene_cedula:
                    print(f"{nombre_doc} NO contiene la c√©dula (ni por OCR rotado)")
                    os.remove(archivo)
                    print(f"archivo eliminado: {archivo}")
                    return False

            except Exception as e:
                print(f"Error aplicando OCR desde PDF: {e}")

        try:
            time.sleep(2)
            os.remove(archivo)
            print(f"archivo eliminado: {archivo}")
        except PermissionError as e:
            print(f"No se pudo eliminar el archivo (en uso): {archivo}")
            print(f"error {e}")
        except Exception as e:
            print(f"Error inesperado al eliminar el archivo:  {e}")
        return contiene_cedula

    except Exception as e:
        print(f"Error general validando {nombre_doc}: {e}")
        return False


def extraer_texto_pdf(archivo):
    try:
        with fitz.open(archivo) as doc:
            contenido = "".join(pagina.get_text() for pagina in doc)
            if contenido.strip():
                return contenido
    except Exception as e:
        print(f"‚ö†Ô∏è Error leyendo PDF con fitz: {e}")

    # Si no se pudo extraer con fitz, intentamos con OCR
    print("üîç Usando OCR para extraer texto del PDF...")
    try:
        imagenes = convert_from_path(archivo)
        texto_ocr = ""
        for i, imagen in enumerate(imagenes):
            texto = pytesseract.image_to_string(imagen, lang="spa")
            texto_ocr += texto + "\n"
        return texto_ocr
    except Exception as e:
        print(f"‚ùå Error al usar OCR: {e}")
        return ""

def validar_documento_rut(x, y, cedula, nombre_doc, driver):
    try:
        time.sleep(2)
        pyautogui.moveTo(x, y, duration=0.5)
        time.sleep(1)
        pyautogui.click()
        print(f"üü° Clic en bot√≥n de descarga para Documento RUT ({x}, {y})")
        time.sleep(2)

        # Validar si se abre la ventana de guardar
        if not esperar_ventana_guardar():
            print("No se abri√≥ la ventana de guardar. Documento inv√°lido.")
            try:
                # Esperar el campo de observaci√≥n espec√≠fico
                textarea_rut = WebDriverWait(driver, 10).until(
                    EC.presence_of_element_located((By.ID, "observacionRut"))
                )
                textarea_rut.clear()
                textarea_rut.send_keys("Documento inv√°lido, revise el documento y vu√©lvalo a cargar.")
                print("Observaci√≥n escrita correctamente en 'observacionRut'.")

                # Buscar el bot√≥n "Rechazar" en el mismo bloque del textarea
                contenedor_rut = textarea_rut.find_element(By.XPATH, "./ancestor::div[contains(@class, 'card')]")
                boton_rechazar = contenedor_rut.find_element(By.XPATH, ".//button[.//span[text()='Rechazar']]")

                # Esperar a que sea clickeable y hacer clic
                WebDriverWait(driver, 5).until(EC.element_to_be_clickable(boton_rechazar)).click()
                print("Bot√≥n 'Rechazar' del bloque Documento RUT clickeado correctamente.")
                return False
            except Exception as e:
                print(f"Error al escribir observaci√≥n o rechazar documento del bloque Documento RUT: {e}")
                return False

        # Continuar con la descarga normal
        pyautogui.hotkey("ctrl", "l")
        pyautogui.write(DESCARGAS_DIR, interval=0.1)
        pyautogui.press("enter")
        pyautogui.press("tab", presses=9, interval=0.1)
        pyautogui.press("enter")

        archivo = esperar_descarga(DESCARGAS_DIR)
        if not archivo:
            print("‚ùå No se detect√≥ un archivo PDF descargado para RUT.")
            return False

        contenido = extraer_texto_pdf(archivo)
        print(f"üìÑ Texto extra√≠do del RUT: {contenido[:300]}...")

        cedula_limpia = limpiar_cedula(cedula)
        contenido_limpio = limpiar_cedula(contenido)
        contiene_cedula = cedula_en_ocr_fuzzy(cedula_limpia, contenido_limpio)

        anio_generado = extraer_anio_generacion(contenido)
        anio_actual = datetime.datetime.now().year
        anio_valido = anio_generado == anio_actual if anio_generado else False

        os.remove(archivo)
        print(f"üóëÔ∏è Archivo eliminado: {archivo}")

        if contiene_cedula and anio_valido:
            print("‚úÖ El RUT contiene la c√©dula y es del a√±o actual.")
            return True
        elif not contiene_cedula:
            print("‚ùå El RUT no contiene la c√©dula.")
            return False
        elif not anio_valido:
            print(f"‚ùå El RUT no es del a√±o actual (actual: {anio_actual}, encontrado: {anio_generado}).")

        return False

    except Exception as e:
        print(f"Error validando RUT: {e}")
        return False


def accionar_segun_validacion(driver, coincide):
    try:
        if not coincide:
            # Espera el campo de observaci√≥n
            textarea_observacion = WebDriverWait(driver, 10).until(
                EC.presence_of_element_located((By.ID, "observacionDoc"))
            )

            # Escribe la observaci√≥n
            textarea_observacion.clear()
            textarea_observacion.send_keys(
                "Documento inv√°lido, revise el documento y vu√©lvalo a cargar"
            )
            print("Observaci√≥n escrita correctamente.")

            # Espera y hace clic en el bot√≥n Rechazar
            boton_rechazar = WebDriverWait(driver, 10).until(
                EC.element_to_be_clickable(
                    (By.XPATH, "//button[.//span[text()='Rechazar']]")
                )
            )
            boton_rechazar.click()
            print("Bot√≥n 'Rechazar' clickeado correctamente.")
        else:
            boton_aprobar = WebDriverWait(driver, 10).until(
                EC.element_to_be_clickable(
                    (By.XPATH, "//button[.//span[text()='Aprobar']]")
                )
            )
            boton_aprobar.click()
            print("Bot√≥n 'Aprobar' clickeado correctamente.")
    except Exception as e:
        print(f"Error al realizar acci√≥n seg√∫n validaci√≥n: {e}")


def accionar_segun_validacion_rut(driver, coincide):
    try:
        if not coincide:
            # Esperar el campo de observaci√≥n espec√≠fico
            textarea_rut = WebDriverWait(driver, 10).until(
                EC.presence_of_element_located((By.ID, "observacionRut"))
            )
            textarea_rut.clear()
            textarea_rut.send_keys("Documento inv√°lido, revise el documento y vu√©lvalo a cargar.")
            print("Observaci√≥n escrita correctamente en 'observacionRut'.")

            # Buscar el bot√≥n "Rechazar" en el mismo bloque del textarea
            contenedor_rut = textarea_rut.find_element(By.XPATH, "./ancestor::div[contains(@class, 'card')]")
            boton_rechazar = contenedor_rut.find_element(By.XPATH, ".//button[.//span[text()='Rechazar']]")

            # Esperar a que sea clickeable y hacer clic
            WebDriverWait(driver, 5).until(EC.element_to_be_clickable(boton_rechazar)).click()
            print("Bot√≥n 'Rechazar' del bloque Documento RUT clickeado correctamente.")
        else:
            textarea_rut = WebDriverWait(driver, 10).until(
                EC.presence_of_element_located((By.ID, "observacionRut"))
            )
            # Buscar el bot√≥n "Rechazar" en el mismo bloque del textarea
            contenedor_rut = textarea_rut.find_element(By.XPATH, "./ancestor::div[contains(@class, 'card')]")
            boton_aceptar = contenedor_rut.find_element(By.XPATH, ".//button[.//span[text()='Aprobar']]")

            # Esperar a que sea clickeable y hacer clic
            WebDriverWait(driver, 5).until(EC.element_to_be_clickable(boton_aceptar)).click()
            print("Bot√≥n 'Aprobar' del bloque Documento RUT clickeado correctamente.")
    except Exception as e:
        print(f"Error al realizar acci√≥n seg√∫n validaci√≥n: {e}")


def registrar_resultado(
    cedula, doc_identidad_valido, doc_rut_valido, fila=None, archivo=EXCEL_OUTPUT):
    try:
        # Intenta cargar el archivo existente
        if os.path.exists(archivo):
            wb = load_workbook(archivo)
            ws = wb.active
        else:
            wb = Workbook()
            ws = wb.active
            ws.append(
                [
                    "C√©dula",
                    "Documento Identidad",
                    "Documento RUT",
                    "Nodo",
                    "Fecha Validaci√≥n",
                    "Hora",
                ]
            )

        
        estado_identidad = "V√°lido" if doc_identidad_valido is True else "Inv√°lido" if doc_identidad_valido is False else f"‚è≠{str(doc_identidad_valido).capitalize()}"
        estado_rut = "V√°lido" if doc_rut_valido is True else "Inv√°lido" if doc_rut_valido is False else f"‚è≠{str(doc_rut_valido).capitalize()}"

        ahora = datetime.datetime.now()
        fecha = ahora.strftime("%Y-%m-%d")
        hora = ahora.strftime("%H:%M:%S")

        nodo = fila["nodos"] if fila is not None and "nodos" in fila else ""

        ws.append([cedula, estado_identidad, estado_rut, nodo, fecha, hora])
        wb.save(archivo)
        print(f"Resultado registrado en {archivo} para c√©dula {cedula} de nodo: {nodo}")
    except Exception as e:
        print(f"Error registrando resultado en Excel: {e}")


def abrir_modal(driver, fila):
    try:

        index = 0
        total_anteriores = 0

        while True:
            filas = WebDriverWait(driver, 10).until(
                EC.presence_of_all_elements_located(
                    (By.XPATH, "//mat-row")
                )
            )
            botones_validos =[]
            for fila1 in filas:
                try:
                    campo_datos = fila1.find_element(
                        By.XPATH, ".//mat-cell[contains(@class, 'mat-column-datosDocumentos')]//span"
                    ).text.strip()
                    if campo_datos.lower() != "null":
                        boton_editar = fila1.find_element(
                            By.XPATH, ".//button[@mattooltip='EDITAR']"
                        )
                        botones_validos.append(boton_editar)
                    else:
                        print("Fila ignorada por contener 'null' en datosDocumentos.")
                except Exception as e:
                    print(f"Error evaluando fila: {e}")

            total_actuales = len(botones_validos)
            print(f"Botones encontrados: {total_actuales} (Index actual: {index})")

            if total_actuales == 0 or index >= total_actuales:
                print("üö´ No hay m√°s botones de editar.")

                print("‚ö†Ô∏è Ya se procesaron todos los botones visibles.")
                # Verificar si hay m√°s p√°ginas
                try:
                    rango = WebDriverWait(driver, 5).until(
                        EC.presence_of_element_located(
                        (By.CSS_SELECTOR, ".mat-mdc-paginator-range-label")
                        )
                        ).text.strip()

                    
                    numeros = list(map(int, re.findall(r"\d+", rango)))
                    if len(numeros) == 3:
                        desde, hasta, total = numeros
                        if hasta < total:
                            # Bot√≥n siguiente activo
                            boton_siguiente = WebDriverWait(driver, 5).until(
                                EC.element_to_be_clickable(
                                    (By.XPATH, "//button[@aria-label='Next page' and not(@disabled)]")
                                )
                            )
                            driver.execute_script("arguments[0].scrollIntoView(true);", boton_siguiente)
                            boton_siguiente.click()
                            print("‚û°Ô∏è Avanzando a la siguiente p√°gina...")
                            index = 0
                            time.sleep(4)  # esperar que cargue la nueva p√°gina
                            continue  # vuelve al while principal
                        else:
                            print("‚úÖ No hay m√°s p√°ginas. Proceso finalizado.")
                            break
                    else:
                        print("‚ö†Ô∏è No se pudo interpretar el rango del paginador.")
                        break
                except Exception as e:
                    print(f"‚ùå Error al intentar avanzar p√°gina: {e}")
                    break


            boton = botones_validos[index]
            try:
                driver.execute_script("arguments[0].scrollIntoView(true);", boton)
                time.sleep(0.5)
                driver.execute_script("arguments[0].click();", boton)
                print(f"Clic en bot√≥n EDITAR #{index + 1}")
                time.sleep(6)

                # Espera a que se cargue el contenido del modal
                modal_scrollable = WebDriverWait(driver, 10).until(
                    EC.presence_of_element_located(
                        (By.CLASS_NAME, "mat-mdc-dialog-content")
                    )
                )

                
                driver.execute_script("arguments[0].scrollTop = 0;", modal_scrollable)
                time.sleep(2)

                cedula = extraer_cedula_modal(driver)
                if cedula:
                    cedula = limpiar_cedula(cedula)  

                    # Validaci√≥n de Documento de Identidad
                    if verificar_archivo_cargado(REGION_IDENTIDAD):
                        estado_doc_id = verificar_aprobacion_documento(driver, "Documento De Identidad")

                        if estado_doc_id is None:
                            doc_identidad_valido = validar_documento_identidad(
                                *COORDENADA_DOC_IDENTIDAD,
                                cedula,
                                "Documento de Identidad",
                            )
                            if not doc_identidad_valido:
                                print("‚ùå Documento de identidad inv√°lido. Se proceder√° a validar backup.")
                                doc_identidad_valido = validacion_backup(cedula, Validacion_backup)

                            accionar_segun_validacion(driver, doc_identidad_valido)

                        elif estado_doc_id == "aprobado":
                            doc_identidad_valido = "Ya aprobado"
                            print("‚úÖ Documento de identidad ya aprobado. Se omite validaci√≥n.")

                        elif estado_doc_id == "rechazado":
                            doc_identidad_valido = "Ya rechazado"
                            print("‚ö†Ô∏è Documento de identidad ya fue rechazado. Se omite validaci√≥n.")
                    else:
                        doc_identidad_valido = "No cargado"
                        print("‚ö†Ô∏è No hay documento de identidad cargado. Se omite la validaci√≥n.")

                    modal_scrollable = WebDriverWait(driver, 10).until(
                        EC.presence_of_element_located(
                            (By.CLASS_NAME, "mat-mdc-dialog-content")
                        )
                        )       

                    
                    driver.execute_script("arguments[0].scrollTop = 0;", modal_scrollable)
                    time.sleep(2)

                    # Validaci√≥n de RUT
                    if verificar_archivo_cargado(REGION_RUT):
                        estado_doc_rut = verificar_aprobacion_documento(driver, "Documento RUT")

                        if estado_doc_rut is None:
                            print("üîç Validando Documento RUT...")
                            doc_rut_valido = validar_documento_rut(
                                *COORDENADA_DOC_RUT, cedula, "Documento RUT", driver
                            )
                            accionar_segun_validacion_rut(driver, doc_rut_valido)
    
                        elif estado_doc_rut == "aprobado":
                            doc_rut_valido = "Ya aprobado"
                            print("‚úÖ Documento RUT ya aprobado. Se omite validaci√≥n.")
    
                        elif estado_doc_rut == "rechazado":
                            doc_rut_valido = "Ya rechazado"
                            print("‚ö†Ô∏è Documento RUT ya fue rechazado. Se omite validaci√≥n.")

                    else:
                        doc_rut_valido = "No cargado"
                        print("‚ö†Ô∏è No hay RUT cargado. Se omite la validaci√≥n.")

                    # Registro de datos excel
                    registrar_resultado(cedula, doc_identidad_valido, doc_rut_valido, fila=fila)
                    try:
                        boton_cerrar = WebDriverWait(driver, 10).until(
                            EC.presence_of_element_located(
                        (By.XPATH, "//button[.//mat-icon[text()='close']]")
                        )
                )
                        driver.execute_script("arguments[0].click();", boton_cerrar)
                        print("Modal cerrado con bot√≥n.")
                        time.sleep(2)
                    except Exception as e:
                        print(f"No se pudo cerrar el modal con el bot√≥n: {e}")

                # Reconectar Selenium tras cerrar el modal
                """try:
                    driver.quit()
                except:
                    pass

                try:
                    driver = conectar_con_selenium()
                    print("Reconectado a Selenium.")
                except Exception as e:
                    print(f"Error reconectando a Selenium: {e}")
                    break"""

                """# Refrescar lista
                boton_refresh = WebDriverWait(driver, 5).until(
                    EC.element_to_be_clickable(
                        (By.XPATH, "//button[.//mat-icon[text()='refresh']]")
                    )
                )
                driver.execute_script("arguments[0].click();", boton_refresh)
                print("üîÅ Refrescando lista...")
                time.sleep(4)"""

                # Revisar si los botones cambiaron
                filas_depues = WebDriverWait(driver, 10).until(
                    EC.presence_of_all_elements_located(
                        (By.XPATH, "//mat-row")
                    )
                )
                botones_despues = []
                for fila1 in filas_depues:
                    try:
                        campo_datos = fila1.find_element(
                            By.XPATH, ".//mat-cell[contains(@class, 'mat-column-datosDocumentos')]//span"
                        ).text.strip()
                        
                        if campo_datos.lower() != "null":
                            boton_editar = fila1.find_element(
                                By.XPATH, ".//button[@mattooltip='EDITAR']"
                            )
                            botones_despues.append(boton_editar)
                    except:
                        continue
                
                total_despues = len(botones_despues)
                if total_despues < total_actuales:
                    print(
                        "Botones disminuyeron tras refresh. Continuando con el siguiente bot√≥n."
                    )
                    total_anteriores = total_despues
                elif total_despues == total_actuales:
                    print(f"Avanzando al siguiente bot√≥n (Index = {index + 1})")
                    index += 1
                    total_anteriores = total_despues
                else:
                    print(
                        "Botones aumentaron. Reiniciando desde el primero por seguridad."
                    )
                    
                    total_anteriores = total_despues

            except Exception as modal_e:
                print(f"Error procesando modal #{index + 1}: {modal_e}")
                index += 1
                continue

    except Exception as e:
        print(f"Error general al abrir modales: {e}")


# ---------- EJECUCI√ìN ----------
if __name__ == "__main__":
    print("Lanzando navegador...")
    lanzar_chrome_con_debug()
    driver = conectar_con_selenium()
    driver.get("https://www.convocatoriasapl.com/convocatorias/#/authentication/signin")
    time.sleep(60)
    
    print("Conectando Selenium...")
    print("Preparando interfaz...")
    print("Abriendo m√≥dulo...")
    time.sleep(15)
    buscar_modulo(driver)

    # üëâ Leer todo el Excel
    df = pd.read_excel(EXCEL_INPUT)

    # üëâ Recorrer cada fila del Excel
    for idx, fila in df.iterrows():
        print(f"\nüîÅ Procesando fila {idx + 1} del Excel...\n")
        try:
            configurar_filtro(driver, fila)
            abrir_modal(driver, fila)
        except Exception as e:
            print(f"‚ùå Error procesando fila {idx + 1}: {e}")
    """time.sleep(5)
    validar_documento_rut(*COORDENADA_DOC_RUT, "1095817281", "documento identidad")"""
    """validacion_backup("1000003581", Validacion_backup)"""

    
    
    

