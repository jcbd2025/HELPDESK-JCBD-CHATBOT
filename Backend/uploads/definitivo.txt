import os
import sys
import subprocess
import webbrowser
import pyautogui
import pygetwindow as gw
import pytesseract
import pandas as pd
import re
import time
import datetime
import openpyxl
from openpyxl import Workbook, load_workbook
from PIL import Image, ImageGrab
from selenium import webdriver
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.action_chains import ActionChains
import fitz
import difflib
from pdf2image import convert_from_path
from PIL import ImageOps, ImageEnhance
from PIL import ImageGrab, Image
import cv2
import numpy as np


pyautogui.FAILSAFE = False

# ---------- CONFIGURACIÓN ----------
pytesseract.pytesseract.tesseract_cmd = (
    r"C:\\Program Files\\Tesseract-OCR\\tesseract.exe"
)
CHROME_PATH = r"C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe"

REGION_IDENTIDAD = (200, 300, 700, 600)
REGION_RUT = (680, 300, 1200, 600)
REGION_MODAL = (150, 150, 900, 300)
COORDENADA_DOC_IDENTIDAD = (597, 431)
COORDENADA_DOC_RUT = (1076, 430)
Validacion_backup = (200, 450, 700, 900)
DESCARGAS_DIR = "C:\\convocatoria"
BASE_DIR = os.path.dirname(
    sys.executable if getattr(sys, "frozen", False) else __file__
)
EXCEL_INPUT = os.path.join(BASE_DIR, "datos.xlsx")
EXCEL_OUTPUT = os.path.join(BASE_DIR, "registro_validaciones.xlsx")

# ---------- FUNCIONES ----------


def lanzar_chrome_con_debug():
    subprocess.Popen(
        [
            CHROME_PATH,
            "--remote-debugging-port=9222",
            "--user-data-dir=C:\\chrome_sesion_temp",
            "--incognito",  # Opcional: modo incógnito
            "--disable-infobars",
            "--disable-extensions",
            "--disable-popup-blocking",
            "--disable-features=site-per-process",
            "--disable-background-timer-throttling",
            "--disable-renderer-backgrounding",
        ]
    )
    time.sleep(5)

"""def abrir_pagina():
    try:
        win = gw.getWindowsWithTitle("Convocatoria")[0]
        win.activate()
        win.maximize()
    except:
        pass"""


def login():
    pyautogui.press("tab", presses=3, interval=0.1)
    pyautogui.write("Val.Doc1", interval=0.1)
    pyautogui.press("tab")
    pyautogui.write("Val.Doc1", interval=0.1)
    pyautogui.press("tab", presses=4, interval=0.1)
    pyautogui.press("space")
    time.sleep(1)
    pyautogui.press("tab", presses=3, interval=0.1)
    pyautogui.press("enter")
    time.sleep(10)


def limpiar_cedula(texto):
    return re.sub(r"\D", "", texto)  


def conectar_con_selenium():
    chrome_options = Options()
    chrome_options.add_experimental_option("debuggerAddress", "localhost:9222")
    chrome_options.add_argument("--disable-extensions")
    chrome_options.add_argument("--disable-popup-blocking")
    return webdriver.Chrome(options=chrome_options)


def buscar_modulo(driver):
    try:
        WebDriverWait(driver, 10).until(
            EC.element_to_be_clickable(
                (By.XPATH, "//span[contains(text(), 'Convocatoria')]")
            )
        ).click()
        print("Clic en 'Convocatoria'.")
        time.sleep(3)
        WebDriverWait(driver, 10).until(
            EC.element_to_be_clickable(
                (By.XPATH, "//a[contains(text(), 'Validación de Documentos')]")
            )
        ).click()
        print("Clic en 'Validación de Documentos'.")
    except Exception as e:
        print(f"Error accediendo al módulo: {e}")


def configurar_filtro(driver, fila):
    valor1 = str(fila["nombre"]).strip()
    valor2 = str(fila["estado"]).strip()
    valor3 = str(fila["nodos"]).strip()
    valor4 = str(fila["sitio"]).strip()
    valor_cargo = str(fila["cargo"]).strip().lower()

    print("Buscando:", valor1, valor2, valor3, valor4)

    try:
        time.sleep(5)
        
        select_elem = WebDriverWait(driver, 10).until(
            EC.presence_of_element_located((By.ID, "mat-select-0"))
        )

        
        driver.execute_script("arguments[0].scrollIntoView(true);", select_elem)
        time.sleep(0.5)

        
        driver.execute_script("arguments[0].click();", select_elem)
        time.sleep(1)

       
        opciones = WebDriverWait(driver, 10).until(
            EC.presence_of_all_elements_located((By.XPATH, "//mat-option"))
        )
        for opt in opciones:
            if opt.text.strip().lower() == valor1.lower():
                opt.click()
                print(f"Proceso seleccionado: {opt.text.strip()}")
                break

    except Exception as e:
        print(f"Error SELECT 1: {e}")
    time.sleep(5)
    try:
        time.sleep(5)
        WebDriverWait(driver, 10).until(
            EC.element_to_be_clickable((By.ID, "mat-select-2"))
        ).click()
        time.sleep(5)
        for opt in WebDriverWait(driver, 10).until(
            EC.presence_of_all_elements_located((By.XPATH, "//mat-option"))
        ):
            if opt.text.strip().lower() == valor2.lower():
                opt.click()
                print(f"Estado seleccionado: {opt.text.strip()}")
                break
    except Exception as e:
        print(f"Error SELECT 2: {e}")
    time.sleep(5)
    try:
        time.sleep(5)
        WebDriverWait(driver, 10).until(
            EC.element_to_be_clickable((By.ID, "mat-select-4"))
        ).click()
        time.sleep(5)
        for opt in WebDriverWait(driver, 10).until(
            EC.presence_of_all_elements_located((By.XPATH, "//mat-option"))
        ):
            if opt.text.strip().lower() == valor3.lower():
                opt.click()
                print(f"Nodo seleccionado: {opt.text.strip()}")
                break
    except Exception as e:
        print(f"Error SELECT 3: {e}")
    time.sleep(5)
    try:
        input_sitio = WebDriverWait(driver, 10).until(
            EC.presence_of_element_located((By.ID, "mat-input-2"))
        )
        input_sitio.click()
        time.sleep(5)
        for opcion in WebDriverWait(driver, 5).until(
            EC.presence_of_all_elements_located((By.XPATH, "//mat-option//span"))
        ):
            if opcion.text.strip().lower() == valor4.lower():
                opcion.click()
                print(f"Sitio '{valor4}' seleccionado.")
                break
    except Exception as e:
        print(f"Error sitio: {e}")
    time.sleep(5)
    try:
        for label in WebDriverWait(driver, 10).until(
            EC.presence_of_all_elements_located(
                (By.XPATH, "//label[@class='mdc-label']")
            )
        ):
            if label.text.strip().lower() == valor_cargo:
                label.click()
                print(f"Cargo '{valor_cargo}' seleccionado.")
                break
    except Exception as e:
        print(f"Error cargo: {e}")
    time.sleep(6)
    try:
        paginador = WebDriverWait(driver, 10).until(
            EC.presence_of_element_located((By.ID, "mat-select-6"))
        )
        driver.execute_script(
            "arguments[0].scrollIntoView({block: 'center'});", paginador
        )
        time.sleep(1)
        paginador.click()
        print("Click en paginador realizado.")
        time.sleep(1)

        
        opciones = WebDriverWait(driver, 10).until(
            EC.presence_of_all_elements_located(
                (By.XPATH, "//div[@role='listbox']//mat-option//span")
            )
        )

        for opcion in opciones:
            texto = opcion.text.strip()
            print(f"🔎 Opción encontrada en paginador: {texto}")
            if texto == "100":
                opcion.click()
                print("100 resultados por página seleccionados.")
                break
        else:
            print("No se encontró la opción '100' en el paginador.")
    except Exception as e:
        print(f"Error en paginador: {e}")
        time.sleep(5)
    

time.sleep(4)


time.sleep(2)


def extraer_cedula_modal(driver):
    try:
        print("Buscando cédula directamente en el HTML del modal...")

        
        elemento_modal = WebDriverWait(driver, 10).until(
            EC.presence_of_element_located((By.CLASS_NAME, "modal-about"))
        )

        texto_modal = elemento_modal.text.strip()
        print(f"Texto del modal: {texto_modal}")

        
        match = re.search(r"Documento\s+(\d+)", texto_modal)
        if match:
            cedula = match.group(1)
            print(f"Cédula extraída del HTML: {cedula}")
            return cedula
        else:
            print("No se encontró la cédula en el texto del modal.")
            return None
    except Exception as e:
        print(f"Error extrayendo cédula desde el DOM: {e}")
        return None


def esperar_descarga(directorio, timeout=15):
    tiempo_inicio = time.time()
    while time.time() - tiempo_inicio < timeout:
        archivos = [f for f in os.listdir(directorio) if f.endswith(".pdf")]
        if archivos:
            archivos.sort(
                key=lambda f: os.path.getmtime(os.path.join(directorio, f)),
                reverse=True,
            )
            return os.path.join(directorio, archivos[0])
        time.sleep(1)
    return None


def verificar_archivo_cargado(region):
    time.sleep(5)
    captura = ImageGrab.grab(bbox=region)
    texto_detectado = pytesseract.image_to_string(captura, lang="spa").lower()
    captura.save("captura_region.png")
    print(f"Texto detectado en la región: {texto_detectado.strip()}")
    return "no ha cargado archivo" not in texto_detectado


def verificar_aprobacion_documento(driver, tipo_documento):
    try:
        titulos = WebDriverWait(driver, 10).until(
            EC.presence_of_all_elements_located((By.CSS_SELECTOR, "h5.card-title"))
        )

        for titulo in titulos:
            if tipo_documento.lower() in titulo.text.lower():
                span = titulo.find_element(By.TAG_NAME, "span")
                estado = span.text.strip().lower()
                print(f"🔍 Estado detectado para {tipo_documento}: {estado.upper()}")

                if "aprobado" in estado:
                    return "aprobado"
                elif "rechazado" in estado:
                    return "rechazado"
                else:
                    return None

        print(f"⚠️ No se encontró el documento '{tipo_documento}' en el DOM.")
        return None

    except Exception as e:
        print(f"❌ Error al verificar aprobación de '{tipo_documento}': {e}")
        return None

def validacion_backup(cedula, region):
    time.sleep(5)

    # Paso 1: Captura original
    captura = ImageGrab.grab(bbox=region)
    captura.save("captura_backup.png")

    # Paso 2: OCR directo sin procesar
    texto_detectado = pytesseract.image_to_string(captura, lang="spa").lower()
    print(f"🕵️ OCR inicial: {texto_detectado.strip()}")

    # Paso 3: Validación directa
    if cedula_en_ocr_fuzzy(limpiar_cedula(cedula), limpiar_cedula(texto_detectado)):
        print("✅ Cédula detectada en OCR sin procesar.")
        return True

    print("⚠️ No detectada en OCR directo. Intentando con preprocesamiento...")

    # Paso 4: Preprocesar (escala de grises + binarización)
    imagen_cv = cv2.cvtColor(np.array(captura), cv2.COLOR_RGB2BGR)
    gris = cv2.cvtColor(imagen_cv, cv2.COLOR_BGR2GRAY)
    _, binarizada = cv2.threshold(gris, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)
    cv2.imwrite("captura_backup_procesada.png", binarizada)

    # Paso 5: OCR mejorado
    texto_mejorado = pytesseract.image_to_string(binarizada, lang="spa").lower()
    print(f"🕵️ OCR mejorado: {texto_mejorado.strip()}")

    # Paso 6: Validación con OCR mejorado
    if cedula_en_ocr_fuzzy(limpiar_cedula(cedula), limpiar_cedula(texto_mejorado)):
        print("✅ Cédula detectada tras preprocesamiento.")
        return True
    else:
        print("❌ Cédula no encontrada ni con preprocesamiento.")
        return False


def extraer_anio_generacion(contenido_pdf):
    # Busca la línea que contiene exactamente "Fecha generación documento PDF: DD-MM-YYYY"
    match = re.search(
        r"Fecha\s+generaci[oó]n\s+documento\s+PDF[:\s]+(\d{2})[-/](\d{2})[-/](\d{4})",
        contenido_pdf,
        re.IGNORECASE,
    )
    if match:
        dia, mes, anio = match.groups()
        print(f"Fecha de generación encontrada: {dia}-{mes}-{anio}")
        return int(anio)
    else:
        print("No se encontró la fecha de generación exacta en el PDF.")
        return None


def cedula_en_ocr_fuzzy(cedula_limpia, texto_limpio, umbral=0.85):
    for i in range(len(texto_limpio) - len(cedula_limpia) + 1):
        segmento = texto_limpio[i : i + len(cedula_limpia)]
        similitud = difflib.SequenceMatcher(None, segmento, cedula_limpia).ratio()
        if similitud >= umbral:
            print(f"Coincidencia fuzzy: {segmento} (similitud {similitud:.2f})")
            return True
    return False


def esperar_ventana_guardar(timeout=5):
    for _ in range(timeout * 2):
        if any(
            "Guardar como" in w.title for w in gw.getWindowsWithTitle("Guardar como")
        ):
            return True
        time.sleep(0.5)
    return False


def validar_documento_identidad(x, y, cedula, nombre_doc):
    try:
        time.sleep(2)
        pyautogui.moveTo(x, y, duration=0.5)
        time.sleep(1)
        pyautogui.click()
        print(f"Clic en botón de descarga para {nombre_doc} ({x}, {y})")
        time.sleep(2)
        if not esperar_ventana_guardar():
            print("No se abrió la ventana de guardar. Documento inválido.")
            try:
                # Esperar el campo de observación específico
                # Espera el campo de observación
                textarea_observacion = WebDriverWait(driver, 10).until(
                    EC.presence_of_element_located((By.ID, "observacionDoc"))
                )

                # Escribe la observación
                textarea_observacion.clear()
                textarea_observacion.send_keys(
                    "Documento inválido, revise el documento y vuélvalo a cargar"
                )
                print("Observación escrita correctamente.")

                # Espera y hace clic en el botón Rechazar
                boton_rechazar = WebDriverWait(driver, 10).until(
                    EC.element_to_be_clickable(
                        (By.XPATH, "//button[.//span[text()='Rechazar']]")
                    )
                )
                boton_rechazar.click()
                print("Botón 'Rechazar' clickeado correctamente.")
                return False
            except Exception as e:
                print(f"Error al escribir observación o rechazar documento del bloque Documento RUT: {e}")
                return False

        pyautogui.hotkey("ctrl", "l")
        pyautogui.write(DESCARGAS_DIR, interval=0.1)
        pyautogui.press("enter")
        pyautogui.press("tab", presses=9, interval=0.1)
        pyautogui.press("enter")

        archivo = esperar_descarga(DESCARGAS_DIR)
        if not archivo:
            print(f"No se detectó un archivo PDF descargado para {nombre_doc}")
            return False

        cedula_limpia = limpiar_cedula(cedula)
        contiene_cedula = False

        # ───────────── Primera validación: TEXTO por PyMuPDF
        try:
            with fitz.open(archivo) as doc:
                contenido_total = ""

                for pagina in doc:
                    texto = pagina.get_text()
                    contenido_total += texto
                    texto_limpio = limpiar_cedula(texto)
                    print(f"Texto extraído de {nombre_doc}: {texto[:300]}...")
                    if cedula_en_ocr_fuzzy(cedula_limpia, texto_limpio):
                        contiene_cedula = True
                        print(f"{nombre_doc} contiene la cédula (por texto plano)")
                        break

                # Verificar si hay páginas rotadas
                if not contiene_cedula:
                    print(
                        "No se encontró por texto plano. Verificando páginas rotadas..."
                    )
                    contenido_rotado = ""
                    for pagina in doc:
                        if pagina.rotation in [90, 180, 270]:
                            pix = pagina.get_pixmap()
                            img = Image.frombytes(
                                "RGB", [pix.width, pix.height], pix.samples
                            )
                            img = img.rotate(-pagina.rotation, expand=True)
                            texto_rotado = pytesseract.image_to_string(img, lang="spa")
                            contenido_rotado += texto_rotado

                    texto_limpio = limpiar_cedula(contenido_rotado)
                    if cedula_en_ocr_fuzzy(cedula_limpia, texto_limpio):
                        contiene_cedula = True
                        print(f"{nombre_doc} contiene la cédula (por texto rotado)")

        except Exception as e:
            print(f"Error al procesar texto del PDF: {e}")

        # ───────────── Segunda validación: OCR con rotación de imagen
        if not contiene_cedula:
            print("No se encontró por texto. Intentando OCR con imágenes rotadas...")
            try:
                imagenes = convert_from_path(
                    archivo, dpi=300, poppler_path=r"C:\poppler-24.08.0\Library\bin"
                )

                for i, imagen in enumerate(imagenes):
                    for angulo in [0, 90, 180, 270]:
                        img = imagen.rotate(angulo, expand=True)
                        img = img.convert("L")
                        img = ImageOps.autocontrast(img)
                        img = ImageEnhance.Contrast(img).enhance(2.5)
                        img = img.resize((img.width * 2, img.height * 2), Image.LANCZOS)

                        custom_config = r"--oem 3 --psm 6 -c tessedit_char_whitelist=0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyzÁÉÍÓÚáéíóú.- "
                        texto_ocr = pytesseract.image_to_string(
                            img, lang="eng", config=custom_config
                        )
                        texto_limpio = limpiar_cedula(texto_ocr)

                        print(
                            f"🔍 OCR para {nombre_doc} (rotado {angulo}°): {texto_ocr[:100]}..."
                        )

                        if cedula_en_ocr_fuzzy(cedula_limpia, texto_limpio):
                            contiene_cedula = True
                            print(
                                f"{nombre_doc} contiene la cédula (por OCR rotado {angulo}°)"
                            )
                            break
                    if contiene_cedula:
                        break

                if not contiene_cedula:
                    print(f"{nombre_doc} NO contiene la cédula (ni por OCR rotado)")
                    os.remove(archivo)
                    print(f"archivo eliminado: {archivo}")
                    return False

            except Exception as e:
                print(f"Error aplicando OCR desde PDF: {e}")

        try:
            time.sleep(2)
            os.remove(archivo)
            print(f"archivo eliminado: {archivo}")
        except PermissionError as e:
            print(f"No se pudo eliminar el archivo (en uso): {archivo}")
            print(f"error {e}")
        except Exception as e:
            print(f"Error inesperado al eliminar el archivo:  {e}")
        return contiene_cedula

    except Exception as e:
        print(f"Error general validando {nombre_doc}: {e}")
        return False


def extraer_texto_pdf(archivo):
    try:
        with fitz.open(archivo) as doc:
            contenido = "".join(pagina.get_text() for pagina in doc)
            if contenido.strip():
                return contenido
    except Exception as e:
        print(f"⚠️ Error leyendo PDF con fitz: {e}")

    # Si no se pudo extraer con fitz, intentamos con OCR
    print("🔍 Usando OCR para extraer texto del PDF...")
    try:
        imagenes = convert_from_path(archivo)
        texto_ocr = ""
        for i, imagen in enumerate(imagenes):
            texto = pytesseract.image_to_string(imagen, lang="spa")
            texto_ocr += texto + "\n"
        return texto_ocr
    except Exception as e:
        print(f"❌ Error al usar OCR: {e}")
        return ""

def validar_documento_rut(x, y, cedula, nombre_doc, driver):
    try:
        time.sleep(2)
        pyautogui.moveTo(x, y, duration=0.5)
        time.sleep(1)
        pyautogui.click()
        print(f"🟡 Clic en botón de descarga para Documento RUT ({x}, {y})")
        time.sleep(2)

        # Validar si se abre la ventana de guardar
        if not esperar_ventana_guardar():
            print("No se abrió la ventana de guardar. Documento inválido.")
            try:
                # Esperar el campo de observación específico
                textarea_rut = WebDriverWait(driver, 10).until(
                    EC.presence_of_element_located((By.ID, "observacionRut"))
                )
                textarea_rut.clear()
                textarea_rut.send_keys("Documento inválido, revise el documento y vuélvalo a cargar.")
                print("Observación escrita correctamente en 'observacionRut'.")

                # Buscar el botón "Rechazar" en el mismo bloque del textarea
                contenedor_rut = textarea_rut.find_element(By.XPATH, "./ancestor::div[contains(@class, 'card')]")
                boton_rechazar = contenedor_rut.find_element(By.XPATH, ".//button[.//span[text()='Rechazar']]")

                # Esperar a que sea clickeable y hacer clic
                WebDriverWait(driver, 5).until(EC.element_to_be_clickable(boton_rechazar)).click()
                print("Botón 'Rechazar' del bloque Documento RUT clickeado correctamente.")
                return False
            except Exception as e:
                print(f"Error al escribir observación o rechazar documento del bloque Documento RUT: {e}")
                return False

        # Continuar con la descarga normal
        pyautogui.hotkey("ctrl", "l")
        pyautogui.write(DESCARGAS_DIR, interval=0.1)
        pyautogui.press("enter")
        pyautogui.press("tab", presses=9, interval=0.1)
        pyautogui.press("enter")

        archivo = esperar_descarga(DESCARGAS_DIR)
        if not archivo:
            print("❌ No se detectó un archivo PDF descargado para RUT.")
            return False

        contenido = extraer_texto_pdf(archivo)
        print(f"📄 Texto extraído del RUT: {contenido[:300]}...")

        cedula_limpia = limpiar_cedula(cedula)
        contenido_limpio = limpiar_cedula(contenido)
        contiene_cedula = cedula_en_ocr_fuzzy(cedula_limpia, contenido_limpio)

        anio_generado = extraer_anio_generacion(contenido)
        anio_actual = datetime.datetime.now().year
        anio_valido = anio_generado == anio_actual if anio_generado else False

        os.remove(archivo)
        print(f"🗑️ Archivo eliminado: {archivo}")

        if contiene_cedula and anio_valido:
            print("✅ El RUT contiene la cédula y es del año actual.")
            return True
        elif not contiene_cedula:
            print("❌ El RUT no contiene la cédula.")
            return False
        elif not anio_valido:
            print(f"❌ El RUT no es del año actual (actual: {anio_actual}, encontrado: {anio_generado}).")

        return False

    except Exception as e:
        print(f"Error validando RUT: {e}")
        return False


def accionar_segun_validacion(driver, coincide):
    try:
        if not coincide:
            # Espera el campo de observación
            textarea_observacion = WebDriverWait(driver, 10).until(
                EC.presence_of_element_located((By.ID, "observacionDoc"))
            )

            # Escribe la observación
            textarea_observacion.clear()
            textarea_observacion.send_keys(
                "Documento inválido, revise el documento y vuélvalo a cargar"
            )
            print("Observación escrita correctamente.")

            # Espera y hace clic en el botón Rechazar
            boton_rechazar = WebDriverWait(driver, 10).until(
                EC.element_to_be_clickable(
                    (By.XPATH, "//button[.//span[text()='Rechazar']]")
                )
            )
            boton_rechazar.click()
            print("Botón 'Rechazar' clickeado correctamente.")
        else:
            boton_aprobar = WebDriverWait(driver, 10).until(
                EC.element_to_be_clickable(
                    (By.XPATH, "//button[.//span[text()='Aprobar']]")
                )
            )
            boton_aprobar.click()
            print("Botón 'Aprobar' clickeado correctamente.")
    except Exception as e:
        print(f"Error al realizar acción según validación: {e}")


def accionar_segun_validacion_rut(driver, coincide):
    try:
        if not coincide:
            # Esperar el campo de observación específico
            textarea_rut = WebDriverWait(driver, 10).until(
                EC.presence_of_element_located((By.ID, "observacionRut"))
            )
            textarea_rut.clear()
            textarea_rut.send_keys("Documento inválido, revise el documento y vuélvalo a cargar.")
            print("Observación escrita correctamente en 'observacionRut'.")

            # Buscar el botón "Rechazar" en el mismo bloque del textarea
            contenedor_rut = textarea_rut.find_element(By.XPATH, "./ancestor::div[contains(@class, 'card')]")
            boton_rechazar = contenedor_rut.find_element(By.XPATH, ".//button[.//span[text()='Rechazar']]")

            # Esperar a que sea clickeable y hacer clic
            WebDriverWait(driver, 5).until(EC.element_to_be_clickable(boton_rechazar)).click()
            print("Botón 'Rechazar' del bloque Documento RUT clickeado correctamente.")
        else:
            textarea_rut = WebDriverWait(driver, 10).until(
                EC.presence_of_element_located((By.ID, "observacionRut"))
            )
            # Buscar el botón "Rechazar" en el mismo bloque del textarea
            contenedor_rut = textarea_rut.find_element(By.XPATH, "./ancestor::div[contains(@class, 'card')]")
            boton_aceptar = contenedor_rut.find_element(By.XPATH, ".//button[.//span[text()='Aprobar']]")

            # Esperar a que sea clickeable y hacer clic
            WebDriverWait(driver, 5).until(EC.element_to_be_clickable(boton_aceptar)).click()
            print("Botón 'Aprobar' del bloque Documento RUT clickeado correctamente.")
    except Exception as e:
        print(f"Error al realizar acción según validación: {e}")


def registrar_resultado(
    cedula, doc_identidad_valido, doc_rut_valido, fila=None, archivo=EXCEL_OUTPUT):
    try:
        # Intenta cargar el archivo existente
        if os.path.exists(archivo):
            wb = load_workbook(archivo)
            ws = wb.active
        else:
            wb = Workbook()
            ws = wb.active
            ws.append(
                [
                    "Cédula",
                    "Documento Identidad",
                    "Documento RUT",
                    "Nodo",
                    "Fecha Validación",
                    "Hora",
                ]
            )

        
        estado_identidad = "Válido" if doc_identidad_valido is True else "Inválido" if doc_identidad_valido is False else f"⏭{str(doc_identidad_valido).capitalize()}"
        estado_rut = "Válido" if doc_rut_valido is True else "Inválido" if doc_rut_valido is False else f"⏭{str(doc_rut_valido).capitalize()}"

        ahora = datetime.datetime.now()
        fecha = ahora.strftime("%Y-%m-%d")
        hora = ahora.strftime("%H:%M:%S")

        nodo = fila["nodos"] if fila is not None and "nodos" in fila else ""

        ws.append([cedula, estado_identidad, estado_rut, nodo, fecha, hora])
        wb.save(archivo)
        print(f"Resultado registrado en {archivo} para cédula {cedula} de nodo: {nodo}")
    except Exception as e:
        print(f"Error registrando resultado en Excel: {e}")


def abrir_modal(driver, fila):
    try:

        index = 0
        total_anteriores = 0

        while True:
            filas = WebDriverWait(driver, 10).until(
                EC.presence_of_all_elements_located(
                    (By.XPATH, "//mat-row")
                )
            )
            botones_validos =[]
            for fila1 in filas:
                try:
                    campo_datos = fila1.find_element(
                        By.XPATH, ".//mat-cell[contains(@class, 'mat-column-datosDocumentos')]//span"
                    ).text.strip()
                    if campo_datos.lower() != "null":
                        boton_editar = fila1.find_element(
                            By.XPATH, ".//button[@mattooltip='EDITAR']"
                        )
                        botones_validos.append(boton_editar)
                    else:
                        print("Fila ignorada por contener 'null' en datosDocumentos.")
                except Exception as e:
                    print(f"Error evaluando fila: {e}")

            total_actuales = len(botones_validos)
            print(f"Botones encontrados: {total_actuales} (Index actual: {index})")

            if total_actuales == 0 or index >= total_actuales:
                print("🚫 No hay más botones de editar.")

                print("⚠️ Ya se procesaron todos los botones visibles.")
                # Verificar si hay más páginas
                try:
                    rango = WebDriverWait(driver, 5).until(
                        EC.presence_of_element_located(
                        (By.CSS_SELECTOR, ".mat-mdc-paginator-range-label")
                        )
                        ).text.strip()

                    
                    numeros = list(map(int, re.findall(r"\d+", rango)))
                    if len(numeros) == 3:
                        desde, hasta, total = numeros
                        if hasta < total:
                            # Botón siguiente activo
                            boton_siguiente = WebDriverWait(driver, 5).until(
                                EC.element_to_be_clickable(
                                    (By.XPATH, "//button[@aria-label='Next page' and not(@disabled)]")
                                )
                            )
                            driver.execute_script("arguments[0].scrollIntoView(true);", boton_siguiente)
                            boton_siguiente.click()
                            print("➡️ Avanzando a la siguiente página...")
                            index = 0
                            time.sleep(4)  # esperar que cargue la nueva página
                            continue  # vuelve al while principal
                        else:
                            print("✅ No hay más páginas. Proceso finalizado.")
                            break
                    else:
                        print("⚠️ No se pudo interpretar el rango del paginador.")
                        break
                except Exception as e:
                    print(f"❌ Error al intentar avanzar página: {e}")
                    break


            boton = botones_validos[index]
            try:
                driver.execute_script("arguments[0].scrollIntoView(true);", boton)
                time.sleep(0.5)
                driver.execute_script("arguments[0].click();", boton)
                print(f"Clic en botón EDITAR #{index + 1}")
                time.sleep(6)

                # Espera a que se cargue el contenido del modal
                modal_scrollable = WebDriverWait(driver, 10).until(
                    EC.presence_of_element_located(
                        (By.CLASS_NAME, "mat-mdc-dialog-content")
                    )
                )

                
                driver.execute_script("arguments[0].scrollTop = 0;", modal_scrollable)
                time.sleep(2)

                cedula = extraer_cedula_modal(driver)
                if cedula:
                    cedula = limpiar_cedula(cedula)  

                    # Validación de Documento de Identidad
                    if verificar_archivo_cargado(REGION_IDENTIDAD):
                        estado_doc_id = verificar_aprobacion_documento(driver, "Documento De Identidad")

                        if estado_doc_id is None:
                            doc_identidad_valido = validar_documento_identidad(
                                *COORDENADA_DOC_IDENTIDAD,
                                cedula,
                                "Documento de Identidad",
                            )
                            if not doc_identidad_valido:
                                print("❌ Documento de identidad inválido. Se procederá a validar backup.")
                                doc_identidad_valido = validacion_backup(cedula, Validacion_backup)

                            accionar_segun_validacion(driver, doc_identidad_valido)

                        elif estado_doc_id == "aprobado":
                            doc_identidad_valido = "Ya aprobado"
                            print("✅ Documento de identidad ya aprobado. Se omite validación.")

                        elif estado_doc_id == "rechazado":
                            doc_identidad_valido = "Ya rechazado"
                            print("⚠️ Documento de identidad ya fue rechazado. Se omite validación.")
                    else:
                        doc_identidad_valido = "No cargado"
                        print("⚠️ No hay documento de identidad cargado. Se omite la validación.")

                    modal_scrollable = WebDriverWait(driver, 10).until(
                        EC.presence_of_element_located(
                            (By.CLASS_NAME, "mat-mdc-dialog-content")
                        )
                        )       

                    
                    driver.execute_script("arguments[0].scrollTop = 0;", modal_scrollable)
                    time.sleep(2)

                    # Validación de RUT
                    if verificar_archivo_cargado(REGION_RUT):
                        estado_doc_rut = verificar_aprobacion_documento(driver, "Documento RUT")

                        if estado_doc_rut is None:
                            print("🔍 Validando Documento RUT...")
                            doc_rut_valido = validar_documento_rut(
                                *COORDENADA_DOC_RUT, cedula, "Documento RUT", driver
                            )
                            accionar_segun_validacion_rut(driver, doc_rut_valido)
    
                        elif estado_doc_rut == "aprobado":
                            doc_rut_valido = "Ya aprobado"
                            print("✅ Documento RUT ya aprobado. Se omite validación.")
    
                        elif estado_doc_rut == "rechazado":
                            doc_rut_valido = "Ya rechazado"
                            print("⚠️ Documento RUT ya fue rechazado. Se omite validación.")

                    else:
                        doc_rut_valido = "No cargado"
                        print("⚠️ No hay RUT cargado. Se omite la validación.")

                    # Registro de datos excel
                    registrar_resultado(cedula, doc_identidad_valido, doc_rut_valido, fila=fila)
                    try:
                        boton_cerrar = WebDriverWait(driver, 10).until(
                            EC.presence_of_element_located(
                        (By.XPATH, "//button[.//mat-icon[text()='close']]")
                        )
                )
                        driver.execute_script("arguments[0].click();", boton_cerrar)
                        print("Modal cerrado con botón.")
                        time.sleep(2)
                    except Exception as e:
                        print(f"No se pudo cerrar el modal con el botón: {e}")

                # Reconectar Selenium tras cerrar el modal
                """try:
                    driver.quit()
                except:
                    pass

                try:
                    driver = conectar_con_selenium()
                    print("Reconectado a Selenium.")
                except Exception as e:
                    print(f"Error reconectando a Selenium: {e}")
                    break"""

                """# Refrescar lista
                boton_refresh = WebDriverWait(driver, 5).until(
                    EC.element_to_be_clickable(
                        (By.XPATH, "//button[.//mat-icon[text()='refresh']]")
                    )
                )
                driver.execute_script("arguments[0].click();", boton_refresh)
                print("🔁 Refrescando lista...")
                time.sleep(4)"""

                # Revisar si los botones cambiaron
                filas_depues = WebDriverWait(driver, 10).until(
                    EC.presence_of_all_elements_located(
                        (By.XPATH, "//mat-row")
                    )
                )
                botones_despues = []
                for fila1 in filas_depues:
                    try:
                        campo_datos = fila1.find_element(
                            By.XPATH, ".//mat-cell[contains(@class, 'mat-column-datosDocumentos')]//span"
                        ).text.strip()
                        
                        if campo_datos.lower() != "null":
                            boton_editar = fila1.find_element(
                                By.XPATH, ".//button[@mattooltip='EDITAR']"
                            )
                            botones_despues.append(boton_editar)
                    except:
                        continue
                
                total_despues = len(botones_despues)
                if total_despues < total_actuales:
                    print(
                        "Botones disminuyeron tras refresh. Continuando con el siguiente botón."
                    )
                    total_anteriores = total_despues
                elif total_despues == total_actuales:
                    print(f"Avanzando al siguiente botón (Index = {index + 1})")
                    index += 1
                    total_anteriores = total_despues
                else:
                    print(
                        "Botones aumentaron. Reiniciando desde el primero por seguridad."
                    )
                    
                    total_anteriores = total_despues

            except Exception as modal_e:
                print(f"Error procesando modal #{index + 1}: {modal_e}")
                index += 1
                continue

    except Exception as e:
        print(f"Error general al abrir modales: {e}")


# ---------- EJECUCIÓN ----------
if __name__ == "__main__":
    print("Lanzando navegador...")
    lanzar_chrome_con_debug()
    driver = conectar_con_selenium()
    driver.get("https://www.convocatoriasapl.com/convocatorias/#/authentication/signin")
    time.sleep(60)
    
    print("Conectando Selenium...")
    print("Preparando interfaz...")
    print("Abriendo módulo...")
    time.sleep(15)
    buscar_modulo(driver)

    # 👉 Leer todo el Excel
    df = pd.read_excel(EXCEL_INPUT)

    # 👉 Recorrer cada fila del Excel
    for idx, fila in df.iterrows():
        print(f"\n🔁 Procesando fila {idx + 1} del Excel...\n")
        try:
            configurar_filtro(driver, fila)
            abrir_modal(driver, fila)
        except Exception as e:
            print(f"❌ Error procesando fila {idx + 1}: {e}")
    """time.sleep(5)
    validar_documento_rut(*COORDENADA_DOC_RUT, "1095817281", "documento identidad")"""
    """validacion_backup("1000003581", Validacion_backup)"""

    
    
    

